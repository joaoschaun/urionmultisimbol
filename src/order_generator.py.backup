"""
Order Generator (Multi-Thread)
Gerencia m√∫ltiplas estrat√©gias em threads independentes
"""

import time
from typing import Dict, List
from loguru import logger

from core.mt5_connector import MT5Connector
from core.config_manager import ConfigManager
from core.risk_manager import RiskManager
from core.strategy_executor import StrategyExecutor
from analysis.technical_analyzer import TechnicalAnalyzer
from analysis.news_analyzer import NewsAnalyzer
from strategies.strategy_manager import StrategyManager
from notifications.telegram_bot import TelegramNotifier


class OrderGenerator:
    """
    Gerador de ordens multi-thread
    Cada estrat√©gia executa em thread independente
    """
    
    def __init__(self):
        """Inicializa Order Generator"""
        
        # Carregar configura√ß√µes
        self.config_manager = ConfigManager()
        self.config = self.config_manager.config
        
        # Componentes compartilhados
        self.mt5 = MT5Connector(self.config)
        self.risk_manager = RiskManager(self.config, self.mt5)
        self.technical_analyzer = TechnicalAnalyzer(self.mt5, self.config)
        self.news_analyzer = NewsAnalyzer(self.config)
        self.strategy_manager = StrategyManager(self.config)
        self.telegram = TelegramNotifier(self.config)
        
        # Criar executors para cada estrat√©gia
        self.executors: List[StrategyExecutor] = []
        self._create_strategy_executors()
        
        # Estado
        self.running = False
        
        logger.info(
            f"OrderGenerator inicializado com "
            f"{len(self.executors)} estrat√©gias independentes"
        )
    
    def _create_strategy_executors(self):
        """Cria executors para cada estrat√©gia ativa"""
        for name, strategy in self.strategy_manager.strategies.items():
            if strategy.is_enabled():
                executor = StrategyExecutor(
                    strategy_name=name,
                    strategy_instance=strategy,
                    config=self.config,
                    mt5=self.mt5,
                    risk_manager=self.risk_manager,
                    technical_analyzer=self.technical_analyzer,
                    news_analyzer=self.news_analyzer
                )
                self.executors.append(executor)
                logger.info(f"Executor criado para: {name}")
    
    def start(self):
        """Inicia todos os executors"""
        if self.running:
            logger.warning("OrderGenerator j√° est√° executando")
            return
        
        self.running = True
        logger.info("Iniciando OrderGenerator (multi-thread)...")
        
        # Conectar MT5
        if not self.mt5.is_connected():
            if not self.mt5.connect():
                logger.error("Falha ao conectar MT5")
                self.running = False
                return
        
        # Iniciar cada executor
        for executor in self.executors:
            executor.start()
        
        logger.success(
            f"‚úÖ OrderGenerator iniciado! "
            f"{len(self.executors)} estrat√©gias operando"
        )
        
        # Loop principal (apenas mant√©m vivo)
        try:
            while self.running:
                time.sleep(60)
        except KeyboardInterrupt:
            logger.info("Interrup√ß√£o detectada")
            self.stop()
    
    def stop(self):
        """Para todos os executors"""
        if not self.running:
            return
        
        logger.info("Parando OrderGenerator...")
        self.running = False
        
        # Parar cada executor
        for executor in self.executors:
            executor.stop()
        
        logger.success("OrderGenerator parado")
    
    def status(self):
        """Exibe status de todas as estrat√©gias"""
        logger.info("=" * 80)
        logger.info("STATUS DO ORDER GENERATOR (MULTI-THREAD)")
        logger.info("=" * 80)
        
        logger.info(f"Running: {self.running}")
        logger.info(f"Executors ativos: {len(self.executors)}")
        
        for executor in self.executors:
            status = "üü¢ Rodando" if executor.running else "üî¥ Parado"
            logger.info(
                f"  [{executor.strategy_name}] {status} - "
                f"Ciclo: {executor.cycle_seconds}s - "
                f"Max Pos: {executor.max_positions} - "
                f"Magic: {executor.magic_number}"
            )
        
        logger.info("=" * 80)
    
    def is_trading_hours(self) -> bool:
        """
        Verifica se est√° dentro do hor√°rio de trading
        
        Returns:
            True se pode operar
        """
        now = datetime.now(timezone.utc)
        current_time = now.hour * 60 + now.minute
        
        # Converter hor√°rios para minutos
        start_time = self.start_hour * 60 + self.start_minute
        end_time = self.end_hour * 60 + self.end_minute
        
        # Hor√°rio cruza meia-noite (ex: 18:30 at√© 16:30 do dia seguinte)
        if start_time > end_time:
            return current_time >= start_time or current_time <= end_time
        else:
            return start_time <= current_time <= end_time
    
    def should_skip_cycle(self) -> tuple[bool, str]:
        """
        Verifica se deve pular este ciclo
        
        Returns:
            (should_skip, reason)
        """
        
        # Verificar se est√° habilitado
        if not self.enabled:
            return True, "OrderGenerator desabilitado"
        
        # Verificar hor√°rio de trading
        if not self.is_trading_hours():
            return True, "Fora do hor√°rio de trading"
        
        # Verificar conex√£o MT5
        if not self.mt5.is_connected():
            logger.warning("MT5 desconectado, tentando reconectar...")
            if not self.mt5.connect():
                return True, "MT5 desconectado"
        
        # Verificar se h√° janela de bloqueio de not√≠cias
        if self.news_analyzer.is_news_blocking_window(self.avoid_news_minutes):
            return True, "Janela de bloqueio de not√≠cias ativa"
        
        return False, ""
    
    def gather_analysis_data(self) -> Optional[Dict]:
        """
        Coleta dados de an√°lise t√©cnica e not√≠cias
        
        Returns:
            Dicion√°rio com an√°lises ou None se falhar
        """
        try:
            # An√°lise t√©cnica multi-timeframe
            technical_analysis = self.technical_analyzer.analyze_multi_timeframe()
            
            if not technical_analysis:
                logger.warning("Falha ao obter an√°lise t√©cnica")
                return None
            
            # An√°lise de not√≠cias
            news_analysis = self.news_analyzer.get_news_signal()
            
            return {
                'technical': technical_analysis,
                'news': news_analysis,
                'timestamp': datetime.now(timezone.utc)
            }
            
        except Exception as e:
            logger.error(f"Erro ao coletar an√°lises: {e}")
            return None
    
    def execute_strategies(self, analysis_data: Dict) -> Optional[Dict]:
        """
        Executa estrat√©gias e retorna sinal de consenso
        
        Args:
            analysis_data: Dados de an√°lise (t√©cnica + not√≠cias)
            
        Returns:
            Sinal de trading ou None
        """
        try:
            technical = analysis_data.get('technical')
            news = analysis_data.get('news')
            
            # Buscar melhor sinal (estrat√©gias independentes)
            signal = self.strategy_manager.get_best_signal(
                technical, news
            )
            
            if signal:
                logger.info(
                    f"Sinal gerado: {signal['action']} "
                    f"(confian√ßa: {signal['confidence']:.2%}) - "
                    f"{signal['strategy']}"
                )
            
            return signal
            
        except Exception as e:
            logger.error(f"Erro ao executar estrat√©gias: {e}")
            return None
    
    def validate_with_risk_manager(self, signal: Dict) -> Optional[Dict]:
        """
        Valida sinal com Risk Manager
        
        Args:
            signal: Sinal de trading
            
        Returns:
            Par√¢metros da ordem ou None se rejeitado
        """
        try:
            action = signal.get('action')
            
            # Verificar se pode abrir posi√ß√£o
            if not self.risk_manager.can_open_position(action):
                logger.info(
                    f"Risk Manager rejeitou abertura de posi√ß√£o {action}"
                )
                return None
            
            # Calcular tamanho da posi√ß√£o
            volume = self.risk_manager.calculate_position_size()
            
            if volume <= 0:
                logger.warning("Volume calculado inv√°lido")
                return None
            
            # Calcular Stop Loss e Take Profit
            sl = self.risk_manager.calculate_stop_loss(action)
            tp = self.risk_manager.calculate_take_profit(action)
            
            if sl is None or tp is None:
                logger.warning("Falha ao calcular SL/TP")
                return None
            
            return {
                'action': action,
                'volume': volume,
                'stop_loss': sl,
                'take_profit': tp,
                'confidence': signal.get('confidence', 0),
                'strategy': signal.get('strategy', 'Unknown'),
                'reason': signal.get('reason', ''),
                'details': signal.get('details', {})
            }
            
        except Exception as e:
            logger.error(f"Erro na valida√ß√£o com Risk Manager: {e}")
            return None
    
    def place_order(self, order_params: Dict) -> bool:
        """
        Executa ordem no MT5
        
        Args:
            order_params: Par√¢metros da ordem
            
        Returns:
            True se ordem executada com sucesso
        """
        try:
            action = order_params['action']
            volume = order_params['volume']
            sl = order_params['stop_loss']
            tp = order_params['take_profit']
            
            # Coment√°rio com informa√ß√µes da estrat√©gia
            comment = (
                f"{order_params['strategy']} - "
                f"Conf: {order_params['confidence']:.1%}"
            )
            
            # Executar ordem
            result = self.mt5.place_order(
                action=action,
                volume=volume,
                stop_loss=sl,
                take_profit=tp,
                comment=comment[:31]  # MT5 limite de 31 caracteres
            )
            
            if result['success']:
                logger.success(
                    f"Ordem {action} executada: Ticket {result['ticket']} | "
                    f"Volume: {volume} | SL: {sl} | TP: {tp}"
                )
                
                # Notificar via Telegram
                self.telegram.send_trade_signal(
                    action=action,
                    price=result.get('price', 0),
                    volume=volume,
                    stop_loss=sl,
                    take_profit=tp,
                    confidence=order_params['confidence'],
                    strategy=order_params['strategy'],
                    reason=order_params['reason']
                )
                
                return True
            else:
                logger.error(f"Falha ao executar ordem: {result['error']}")
                return False
                
        except Exception as e:
            logger.error(f"Erro ao executar ordem: {e}")
            return False
    
    def execute_cycle(self):
        """Executa um ciclo completo de an√°lise e gera√ß√£o de ordem"""
        
        logger.info("=" * 60)
        logger.info(f"Iniciando ciclo - {datetime.now(timezone.utc)}")
        
        # Verificar se deve pular
        should_skip, reason = self.should_skip_cycle()
        if should_skip:
            logger.info(f"Ciclo pulado: {reason}")
            return
        
        # 1. Coletar an√°lises
        logger.info("Coletando an√°lises t√©cnicas e not√≠cias...")
        analysis_data = self.gather_analysis_data()
        
        if not analysis_data:
            logger.warning("Falha ao coletar an√°lises, pulando ciclo")
            return
        
        # 2. Executar estrat√©gias
        logger.info("Executando estrat√©gias...")
        signal = self.execute_strategies(analysis_data)
        
        if not signal or signal.get('action') == 'HOLD':
            logger.info("Nenhum sinal de trading v√°lido gerado")
            return
        
        # 3. Validar com Risk Manager
        logger.info("Validando com Risk Manager...")
        order_params = self.validate_with_risk_manager(signal)
        
        if not order_params:
            logger.info("Ordem rejeitada pelo Risk Manager")
            return
        
        # 4. Executar ordem
        logger.info(
            f"Executando ordem {order_params['action']} "
            f"(volume: {order_params['volume']})..."
        )
        success = self.place_order(order_params)
        
        if success:
            logger.success("Ciclo conclu√≠do com sucesso - Ordem executada")
        else:
            logger.error("Ciclo conclu√≠do - Falha ao executar ordem")
        
        self.last_execution = datetime.now(timezone.utc)
    
    def start(self):
        """Inicia loop de execu√ß√£o"""
        
        if self.running:
            logger.warning("OrderGenerator j√° est√° executando")
            return
        
        logger.info("Iniciando OrderGenerator...")
        self.running = True
        
        try:
            while self.running:
                try:
                    self.execute_cycle()
                except Exception as e:
                    logger.error(f"Erro no ciclo: {e}")
                
                # Aguardar pr√≥ximo ciclo
                logger.info(f"Aguardando {self.cycle_interval}s...")
                time.sleep(self.cycle_interval)
                
        except KeyboardInterrupt:
            logger.info("Interrup√ß√£o pelo usu√°rio")
        finally:
            self.stop()
    
    def stop(self):
        """Para execu√ß√£o"""
        logger.info("Parando OrderGenerator...")
        self.running = False
        
        # Desconectar MT5
        if self.mt5.is_connected():
            self.mt5.disconnect()
        
        logger.info("OrderGenerator parado")


if __name__ == "__main__":
    # Executar Order Generator
    generator = OrderGenerator()
    generator.start()
